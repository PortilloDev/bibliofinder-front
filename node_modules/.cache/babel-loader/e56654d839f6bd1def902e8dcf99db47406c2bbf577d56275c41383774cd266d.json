{"ast":null,"code":"import GoogleBooksAdapter from './api/GoogleBooksAdapter';\nimport OpenLibraryAdapter from './api/OpenLibraryAdapter';\nclass BookService {\n  constructor() {\n    // Initialize adapters\n    this.googleBooks = new GoogleBooksAdapter();\n    this.openLibrary = new OpenLibraryAdapter();\n\n    // Default primary and fallback APIs\n    this.primaryAPI = this.googleBooks;\n    this.fallbackAPI = this.openLibrary;\n\n    // Cache for search results\n    this.searchCache = new Map();\n    this.cacheTimeout = 5 * 60 * 1000; // 5 minutes\n  }\n\n  // Configure which API to use as primary\n  setPrimaryAPI(apiName, apiKey = null) {\n    switch (apiName.toLowerCase()) {\n      case 'google':\n      case 'googlebooks':\n        this.primaryAPI = new GoogleBooksAdapter(apiKey);\n        break;\n      case 'openlibrary':\n        this.primaryAPI = this.openLibrary;\n        break;\n      default:\n        console.warn(`Unknown API: ${apiName}, keeping current primary API`);\n    }\n  }\n\n  // Add a new API adapter\n  addAPIAdapter(name, adapter) {\n    this[name] = adapter;\n  }\n\n  // Generate cache key\n  getCacheKey(method, params) {\n    return `${method}_${JSON.stringify(params)}`;\n  }\n\n  // Check cache validity\n  isCacheValid(cacheEntry) {\n    return Date.now() - cacheEntry.timestamp < this.cacheTimeout;\n  }\n\n  // Search books with fallback mechanism\n  async searchBooks(query, options = {}) {\n    if (!query.trim()) {\n      return {\n        success: false,\n        error: 'Query cannot be empty',\n        books: [],\n        totalItems: 0,\n        hasMore: false\n      };\n    }\n    const cacheKey = this.getCacheKey('search', {\n      query,\n      options\n    });\n\n    // Check cache first\n    if (this.searchCache.has(cacheKey)) {\n      const cached = this.searchCache.get(cacheKey);\n      if (this.isCacheValid(cached)) {\n        return cached.data;\n      } else {\n        this.searchCache.delete(cacheKey);\n      }\n    }\n    try {\n      // Try primary API first\n      let result = await this.primaryAPI.search(query, options);\n\n      // If primary API fails or returns no results, try fallback\n      if (!result.success || result.books.length === 0) {\n        console.log('Primary API failed or no results, trying fallback API...');\n        result = await this.fallbackAPI.search(query, options);\n        if (result.success) {\n          result.source = 'fallback';\n        }\n      } else {\n        result.source = 'primary';\n      }\n\n      // Cache successful results\n      if (result.success && result.books.length > 0) {\n        this.searchCache.set(cacheKey, {\n          data: result,\n          timestamp: Date.now()\n        });\n      }\n      return result;\n    } catch (error) {\n      console.error('Book search error:', error);\n      return {\n        success: false,\n        error: error.message,\n        books: [],\n        totalItems: 0,\n        hasMore: false\n      };\n    }\n  }\n\n  // Get book details with fallback\n  async getBookDetails(bookId, source = null) {\n    const cacheKey = this.getCacheKey('details', {\n      bookId,\n      source\n    });\n\n    // Check cache first\n    if (this.searchCache.has(cacheKey)) {\n      const cached = this.searchCache.get(cacheKey);\n      if (this.isCacheValid(cached)) {\n        return cached.data;\n      } else {\n        this.searchCache.delete(cacheKey);\n      }\n    }\n    try {\n      let result;\n\n      // If source is specified, use that API\n      if (source === 'google-books' && this.googleBooks) {\n        result = await this.googleBooks.getBookDetails(bookId);\n      } else if (source === 'open-library' && this.openLibrary) {\n        result = await this.openLibrary.getBookDetails(bookId);\n      } else {\n        // Try primary API first\n        result = await this.primaryAPI.getBookDetails(bookId);\n\n        // If primary fails, try fallback\n        if (!result.success) {\n          result = await this.fallbackAPI.getBookDetails(bookId);\n        }\n      }\n\n      // Cache successful results\n      if (result.success && result.book) {\n        this.searchCache.set(cacheKey, {\n          data: result,\n          timestamp: Date.now()\n        });\n      }\n      return result;\n    } catch (error) {\n      console.error('Book details error:', error);\n      return {\n        success: false,\n        error: error.message,\n        book: null\n      };\n    }\n  }\n\n  // Search by specific criteria\n  async searchByAuthor(author, options = {}) {\n    try {\n      let result = await this.primaryAPI.searchByAuthor(author, options);\n      if (!result.success || result.books.length === 0) {\n        result = await this.fallbackAPI.searchByAuthor(author, options);\n      }\n      return result;\n    } catch (error) {\n      console.error('Author search error:', error);\n      return {\n        success: false,\n        error: error.message,\n        books: [],\n        totalItems: 0,\n        hasMore: false\n      };\n    }\n  }\n  async searchByTitle(title, options = {}) {\n    try {\n      let result = await this.primaryAPI.searchByTitle(title, options);\n      if (!result.success || result.books.length === 0) {\n        result = await this.fallbackAPI.searchByTitle(title, options);\n      }\n      return result;\n    } catch (error) {\n      console.error('Title search error:', error);\n      return {\n        success: false,\n        error: error.message,\n        books: [],\n        totalItems: 0,\n        hasMore: false\n      };\n    }\n  }\n  async searchByISBN(isbn, options = {}) {\n    try {\n      let result = await this.primaryAPI.searchByISBN(isbn, options);\n      if (!result.success || result.books.length === 0) {\n        result = await this.fallbackAPI.searchByISBN(isbn, options);\n      }\n      return result;\n    } catch (error) {\n      console.error('ISBN search error:', error);\n      return {\n        success: false,\n        error: error.message,\n        books: [],\n        totalItems: 0,\n        hasMore: false\n      };\n    }\n  }\n  async searchBySubject(subject, options = {}) {\n    try {\n      let result = await this.primaryAPI.searchBySubject(subject, options);\n      if (!result.success || result.books.length === 0) {\n        result = await this.fallbackAPI.searchBySubject(subject, options);\n      }\n      return result;\n    } catch (error) {\n      console.error('Subject search error:', error);\n      return {\n        success: false,\n        error: error.message,\n        books: [],\n        totalItems: 0,\n        hasMore: false\n      };\n    }\n  }\n\n  // Get popular/trending books (mock implementation)\n  async getPopularBooks(options = {}) {\n    const queries = ['bestseller 2024', 'popular fiction', 'top rated books', 'award winning books'];\n    try {\n      const randomQuery = queries[Math.floor(Math.random() * queries.length)];\n      return await this.searchBooks(randomQuery, {\n        ...options,\n        maxResults: 10\n      });\n    } catch (error) {\n      console.error('Popular books error:', error);\n      return {\n        success: false,\n        error: error.message,\n        books: [],\n        totalItems: 0,\n        hasMore: false\n      };\n    }\n  }\n\n  // Clear cache\n  clearCache() {\n    this.searchCache.clear();\n  }\n\n  // Get cache statistics\n  getCacheStats() {\n    const totalEntries = this.searchCache.size;\n    const validEntries = Array.from(this.searchCache.values()).filter(entry => this.isCacheValid(entry)).length;\n    return {\n      totalEntries,\n      validEntries,\n      invalidEntries: totalEntries - validEntries\n    };\n  }\n}\n\n// Create singleton instance\nconst bookService = new BookService();\nexport default bookService;","map":{"version":3,"names":["GoogleBooksAdapter","OpenLibraryAdapter","BookService","constructor","googleBooks","openLibrary","primaryAPI","fallbackAPI","searchCache","Map","cacheTimeout","setPrimaryAPI","apiName","apiKey","toLowerCase","console","warn","addAPIAdapter","name","adapter","getCacheKey","method","params","JSON","stringify","isCacheValid","cacheEntry","Date","now","timestamp","searchBooks","query","options","trim","success","error","books","totalItems","hasMore","cacheKey","has","cached","get","data","delete","result","search","length","log","source","set","message","getBookDetails","bookId","book","searchByAuthor","author","searchByTitle","title","searchByISBN","isbn","searchBySubject","subject","getPopularBooks","queries","randomQuery","Math","floor","random","maxResults","clearCache","clear","getCacheStats","totalEntries","size","validEntries","Array","from","values","filter","entry","invalidEntries","bookService"],"sources":["/Applications/Projects/bibliofinder-front/src/services/BookService.js"],"sourcesContent":["import GoogleBooksAdapter from './api/GoogleBooksAdapter';\nimport OpenLibraryAdapter from './api/OpenLibraryAdapter';\n\nclass BookService {\n  constructor() {\n    // Initialize adapters\n    this.googleBooks = new GoogleBooksAdapter();\n    this.openLibrary = new OpenLibraryAdapter();\n    \n    // Default primary and fallback APIs\n    this.primaryAPI = this.googleBooks;\n    this.fallbackAPI = this.openLibrary;\n    \n    // Cache for search results\n    this.searchCache = new Map();\n    this.cacheTimeout = 5 * 60 * 1000; // 5 minutes\n  }\n\n  // Configure which API to use as primary\n  setPrimaryAPI(apiName, apiKey = null) {\n    switch (apiName.toLowerCase()) {\n      case 'google':\n      case 'googlebooks':\n        this.primaryAPI = new GoogleBooksAdapter(apiKey);\n        break;\n      case 'openlibrary':\n        this.primaryAPI = this.openLibrary;\n        break;\n      default:\n        console.warn(`Unknown API: ${apiName}, keeping current primary API`);\n    }\n  }\n\n  // Add a new API adapter\n  addAPIAdapter(name, adapter) {\n    this[name] = adapter;\n  }\n\n  // Generate cache key\n  getCacheKey(method, params) {\n    return `${method}_${JSON.stringify(params)}`;\n  }\n\n  // Check cache validity\n  isCacheValid(cacheEntry) {\n    return Date.now() - cacheEntry.timestamp < this.cacheTimeout;\n  }\n\n  // Search books with fallback mechanism\n  async searchBooks(query, options = {}) {\n    if (!query.trim()) {\n      return {\n        success: false,\n        error: 'Query cannot be empty',\n        books: [],\n        totalItems: 0,\n        hasMore: false\n      };\n    }\n\n    const cacheKey = this.getCacheKey('search', { query, options });\n    \n    // Check cache first\n    if (this.searchCache.has(cacheKey)) {\n      const cached = this.searchCache.get(cacheKey);\n      if (this.isCacheValid(cached)) {\n        return cached.data;\n      } else {\n        this.searchCache.delete(cacheKey);\n      }\n    }\n\n    try {\n      // Try primary API first\n      let result = await this.primaryAPI.search(query, options);\n      \n      // If primary API fails or returns no results, try fallback\n      if (!result.success || result.books.length === 0) {\n        console.log('Primary API failed or no results, trying fallback API...');\n        result = await this.fallbackAPI.search(query, options);\n        \n        if (result.success) {\n          result.source = 'fallback';\n        }\n      } else {\n        result.source = 'primary';\n      }\n\n      // Cache successful results\n      if (result.success && result.books.length > 0) {\n        this.searchCache.set(cacheKey, {\n          data: result,\n          timestamp: Date.now()\n        });\n      }\n\n      return result;\n    } catch (error) {\n      console.error('Book search error:', error);\n      return {\n        success: false,\n        error: error.message,\n        books: [],\n        totalItems: 0,\n        hasMore: false\n      };\n    }\n  }\n\n  // Get book details with fallback\n  async getBookDetails(bookId, source = null) {\n    const cacheKey = this.getCacheKey('details', { bookId, source });\n    \n    // Check cache first\n    if (this.searchCache.has(cacheKey)) {\n      const cached = this.searchCache.get(cacheKey);\n      if (this.isCacheValid(cached)) {\n        return cached.data;\n      } else {\n        this.searchCache.delete(cacheKey);\n      }\n    }\n\n    try {\n      let result;\n      \n      // If source is specified, use that API\n      if (source === 'google-books' && this.googleBooks) {\n        result = await this.googleBooks.getBookDetails(bookId);\n      } else if (source === 'open-library' && this.openLibrary) {\n        result = await this.openLibrary.getBookDetails(bookId);\n      } else {\n        // Try primary API first\n        result = await this.primaryAPI.getBookDetails(bookId);\n        \n        // If primary fails, try fallback\n        if (!result.success) {\n          result = await this.fallbackAPI.getBookDetails(bookId);\n        }\n      }\n\n      // Cache successful results\n      if (result.success && result.book) {\n        this.searchCache.set(cacheKey, {\n          data: result,\n          timestamp: Date.now()\n        });\n      }\n\n      return result;\n    } catch (error) {\n      console.error('Book details error:', error);\n      return {\n        success: false,\n        error: error.message,\n        book: null\n      };\n    }\n  }\n\n  // Search by specific criteria\n  async searchByAuthor(author, options = {}) {\n    try {\n      let result = await this.primaryAPI.searchByAuthor(author, options);\n      \n      if (!result.success || result.books.length === 0) {\n        result = await this.fallbackAPI.searchByAuthor(author, options);\n      }\n\n      return result;\n    } catch (error) {\n      console.error('Author search error:', error);\n      return {\n        success: false,\n        error: error.message,\n        books: [],\n        totalItems: 0,\n        hasMore: false\n      };\n    }\n  }\n\n  async searchByTitle(title, options = {}) {\n    try {\n      let result = await this.primaryAPI.searchByTitle(title, options);\n      \n      if (!result.success || result.books.length === 0) {\n        result = await this.fallbackAPI.searchByTitle(title, options);\n      }\n\n      return result;\n    } catch (error) {\n      console.error('Title search error:', error);\n      return {\n        success: false,\n        error: error.message,\n        books: [],\n        totalItems: 0,\n        hasMore: false\n      };\n    }\n  }\n\n  async searchByISBN(isbn, options = {}) {\n    try {\n      let result = await this.primaryAPI.searchByISBN(isbn, options);\n      \n      if (!result.success || result.books.length === 0) {\n        result = await this.fallbackAPI.searchByISBN(isbn, options);\n      }\n\n      return result;\n    } catch (error) {\n      console.error('ISBN search error:', error);\n      return {\n        success: false,\n        error: error.message,\n        books: [],\n        totalItems: 0,\n        hasMore: false\n      };\n    }\n  }\n\n  async searchBySubject(subject, options = {}) {\n    try {\n      let result = await this.primaryAPI.searchBySubject(subject, options);\n      \n      if (!result.success || result.books.length === 0) {\n        result = await this.fallbackAPI.searchBySubject(subject, options);\n      }\n\n      return result;\n    } catch (error) {\n      console.error('Subject search error:', error);\n      return {\n        success: false,\n        error: error.message,\n        books: [],\n        totalItems: 0,\n        hasMore: false\n      };\n    }\n  }\n\n  // Get popular/trending books (mock implementation)\n  async getPopularBooks(options = {}) {\n    const queries = [\n      'bestseller 2024',\n      'popular fiction',\n      'top rated books',\n      'award winning books'\n    ];\n    \n    try {\n      const randomQuery = queries[Math.floor(Math.random() * queries.length)];\n      return await this.searchBooks(randomQuery, { ...options, maxResults: 10 });\n    } catch (error) {\n      console.error('Popular books error:', error);\n      return {\n        success: false,\n        error: error.message,\n        books: [],\n        totalItems: 0,\n        hasMore: false\n      };\n    }\n  }\n\n  // Clear cache\n  clearCache() {\n    this.searchCache.clear();\n  }\n\n  // Get cache statistics\n  getCacheStats() {\n    const totalEntries = this.searchCache.size;\n    const validEntries = Array.from(this.searchCache.values())\n      .filter(entry => this.isCacheValid(entry)).length;\n    \n    return {\n      totalEntries,\n      validEntries,\n      invalidEntries: totalEntries - validEntries\n    };\n  }\n}\n\n// Create singleton instance\nconst bookService = new BookService();\n\nexport default bookService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
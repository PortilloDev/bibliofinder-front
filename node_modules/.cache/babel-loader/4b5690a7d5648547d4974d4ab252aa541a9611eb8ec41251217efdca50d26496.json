{"ast":null,"code":"// Image caching utility for book covers\nclass ImageCache {\n  constructor() {\n    this.cache = new Map();\n    this.loading = new Set();\n    this.maxCacheSize = 200; // Maximum number of cached images\n    this.cacheDuration = 24 * 60 * 60 * 1000; // 24 hours in milliseconds\n  }\n\n  // Generate cache key from image URL\n  getCacheKey(url) {\n    return btoa(url).replace(/[^a-zA-Z0-9]/g, '');\n  }\n\n  // Check if image is in cache and still valid\n  isValidCache(cacheEntry) {\n    return Date.now() - cacheEntry.timestamp < this.cacheDuration;\n  }\n\n  // Get cached image or load new one\n  async getCachedImage(imageUrl, fallbackUrl = null) {\n    if (!imageUrl) {\n      return this.getPlaceholderImage();\n    }\n    const cacheKey = this.getCacheKey(imageUrl);\n\n    // Check if already cached and valid\n    if (this.cache.has(cacheKey)) {\n      const cached = this.cache.get(cacheKey);\n      if (this.isValidCache(cached)) {\n        return cached.dataUrl;\n      } else {\n        // Remove expired cache entry\n        this.cache.delete(cacheKey);\n      }\n    }\n\n    // Check if already loading\n    if (this.loading.has(cacheKey)) {\n      return this.getPlaceholderImage();\n    }\n\n    // Load and cache image\n    try {\n      this.loading.add(cacheKey);\n      const dataUrl = await this.loadImageAsDataUrl(imageUrl);\n\n      // Clean cache if it's getting too large\n      if (this.cache.size >= this.maxCacheSize) {\n        this.cleanCache();\n      }\n\n      // Store in cache\n      this.cache.set(cacheKey, {\n        dataUrl,\n        timestamp: Date.now(),\n        originalUrl: imageUrl\n      });\n      this.loading.delete(cacheKey);\n      return dataUrl;\n    } catch (error) {\n      this.loading.delete(cacheKey);\n\n      // Try fallback URL if provided\n      if (fallbackUrl && fallbackUrl !== imageUrl) {\n        return this.getCachedImage(fallbackUrl);\n      }\n      console.warn('Failed to load image:', imageUrl, error);\n      return this.getPlaceholderImage();\n    }\n  }\n\n  // Load image and convert to data URL\n  loadImageAsDataUrl(imageUrl) {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      img.crossOrigin = 'anonymous';\n      img.onload = () => {\n        try {\n          const canvas = document.createElement('canvas');\n          const ctx = canvas.getContext('2d');\n          canvas.width = img.width;\n          canvas.height = img.height;\n          ctx.drawImage(img, 0, 0);\n          const dataUrl = canvas.toDataURL('image/jpeg', 0.8);\n          resolve(dataUrl);\n        } catch (error) {\n          reject(error);\n        }\n      };\n      img.onerror = () => {\n        reject(new Error(`Failed to load image: ${imageUrl}`));\n      };\n\n      // Add cache-busting and error handling\n      const urlWithParams = this.addCacheBusting(imageUrl);\n      img.src = urlWithParams;\n    });\n  }\n\n  // Add cache-busting parameters to URL\n  addCacheBusting(url) {\n    try {\n      const urlObj = new URL(url);\n      // Only add cache-busting if it's not already there\n      if (!urlObj.searchParams.has('_cb')) {\n        urlObj.searchParams.set('_cb', Date.now().toString(36));\n      }\n      return urlObj.toString();\n    } catch (error) {\n      // If URL is malformed, return as-is\n      return url;\n    }\n  }\n\n  // Generate placeholder image\n  getPlaceholderImage() {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    canvas.width = 200;\n    canvas.height = 300;\n\n    // Create gradient background\n    const gradient = ctx.createLinearGradient(0, 0, 0, 300);\n    gradient.addColorStop(0, '#f3f4f6');\n    gradient.addColorStop(1, '#e5e7eb');\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, 200, 300);\n\n    // Add book icon\n    ctx.fillStyle = '#9ca3af';\n    ctx.font = '48px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText('ðŸ“š', 100, 150);\n\n    // Add text\n    ctx.fillStyle = '#6b7280';\n    ctx.font = '14px Arial';\n    ctx.fillText('Sin portada', 100, 200);\n    return canvas.toDataURL('image/png');\n  }\n\n  // Clean old cache entries\n  cleanCache() {\n    const entries = Array.from(this.cache.entries());\n\n    // Sort by timestamp (oldest first)\n    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);\n\n    // Remove oldest 25% of entries\n    const toRemove = Math.floor(entries.length * 0.25);\n    for (let i = 0; i < toRemove; i++) {\n      this.cache.delete(entries[i][0]);\n    }\n  }\n\n  // Get cache statistics\n  getCacheStats() {\n    const totalSize = this.cache.size;\n    const loadingCount = this.loading.size;\n\n    // Calculate total cache size in bytes (approximate)\n    let totalBytes = 0;\n    this.cache.forEach(entry => {\n      // Approximate data URL size\n      totalBytes += entry.dataUrl.length;\n    });\n    return {\n      totalImages: totalSize,\n      loadingImages: loadingCount,\n      approximateSize: this.formatBytes(totalBytes),\n      maxCacheSize: this.maxCacheSize\n    };\n  }\n\n  // Format bytes for display\n  formatBytes(bytes) {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n\n  // Clear all cache\n  clearCache() {\n    this.cache.clear();\n    this.loading.clear();\n  }\n\n  // Preload images for better UX\n  async preloadImages(imageUrls) {\n    const promises = imageUrls.filter(url => url).map(url => this.getCachedImage(url).catch(() => null));\n    await Promise.allSettled(promises);\n  }\n\n  // Get optimized image URL based on size requirements\n  getOptimizedImageUrl(imageLinks, size = 'medium') {\n    if (!imageLinks || typeof imageLinks !== 'object') {\n      return null;\n    }\n\n    // Priority order for different sizes\n    const sizePriority = {\n      thumbnail: ['thumbnail', 'small', 'medium', 'large'],\n      small: ['small', 'thumbnail', 'medium', 'large'],\n      medium: ['medium', 'small', 'large', 'thumbnail'],\n      large: ['large', 'medium', 'small', 'thumbnail']\n    };\n    const priorities = sizePriority[size] || sizePriority.medium;\n    for (const priority of priorities) {\n      if (imageLinks[priority]) {\n        return imageLinks[priority];\n      }\n    }\n    return null;\n  }\n}\n\n// Create singleton instance\nconst imageCache = new ImageCache();\nexport default imageCache;","map":{"version":3,"names":["ImageCache","constructor","cache","Map","loading","Set","maxCacheSize","cacheDuration","getCacheKey","url","btoa","replace","isValidCache","cacheEntry","Date","now","timestamp","getCachedImage","imageUrl","fallbackUrl","getPlaceholderImage","cacheKey","has","cached","get","dataUrl","delete","add","loadImageAsDataUrl","size","cleanCache","set","originalUrl","error","console","warn","Promise","resolve","reject","img","Image","crossOrigin","onload","canvas","document","createElement","ctx","getContext","width","height","drawImage","toDataURL","onerror","Error","urlWithParams","addCacheBusting","src","urlObj","URL","searchParams","toString","gradient","createLinearGradient","addColorStop","fillStyle","fillRect","font","textAlign","fillText","entries","Array","from","sort","a","b","toRemove","Math","floor","length","i","getCacheStats","totalSize","loadingCount","totalBytes","forEach","entry","totalImages","loadingImages","approximateSize","formatBytes","bytes","k","sizes","log","parseFloat","pow","toFixed","clearCache","clear","preloadImages","imageUrls","promises","filter","map","catch","allSettled","getOptimizedImageUrl","imageLinks","sizePriority","thumbnail","small","medium","large","priorities","priority","imageCache"],"sources":["/Applications/Projects/bibliofinder-front/src/utils/imageCache.js"],"sourcesContent":["// Image caching utility for book covers\nclass ImageCache {\n  constructor() {\n    this.cache = new Map();\n    this.loading = new Set();\n    this.maxCacheSize = 200; // Maximum number of cached images\n    this.cacheDuration = 24 * 60 * 60 * 1000; // 24 hours in milliseconds\n  }\n\n  // Generate cache key from image URL\n  getCacheKey(url) {\n    return btoa(url).replace(/[^a-zA-Z0-9]/g, '');\n  }\n\n  // Check if image is in cache and still valid\n  isValidCache(cacheEntry) {\n    return Date.now() - cacheEntry.timestamp < this.cacheDuration;\n  }\n\n  // Get cached image or load new one\n  async getCachedImage(imageUrl, fallbackUrl = null) {\n    if (!imageUrl) {\n      return this.getPlaceholderImage();\n    }\n\n    const cacheKey = this.getCacheKey(imageUrl);\n    \n    // Check if already cached and valid\n    if (this.cache.has(cacheKey)) {\n      const cached = this.cache.get(cacheKey);\n      if (this.isValidCache(cached)) {\n        return cached.dataUrl;\n      } else {\n        // Remove expired cache entry\n        this.cache.delete(cacheKey);\n      }\n    }\n\n    // Check if already loading\n    if (this.loading.has(cacheKey)) {\n      return this.getPlaceholderImage();\n    }\n\n    // Load and cache image\n    try {\n      this.loading.add(cacheKey);\n      const dataUrl = await this.loadImageAsDataUrl(imageUrl);\n      \n      // Clean cache if it's getting too large\n      if (this.cache.size >= this.maxCacheSize) {\n        this.cleanCache();\n      }\n\n      // Store in cache\n      this.cache.set(cacheKey, {\n        dataUrl,\n        timestamp: Date.now(),\n        originalUrl: imageUrl\n      });\n\n      this.loading.delete(cacheKey);\n      return dataUrl;\n    } catch (error) {\n      this.loading.delete(cacheKey);\n      \n      // Try fallback URL if provided\n      if (fallbackUrl && fallbackUrl !== imageUrl) {\n        return this.getCachedImage(fallbackUrl);\n      }\n      \n      console.warn('Failed to load image:', imageUrl, error);\n      return this.getPlaceholderImage();\n    }\n  }\n\n  // Load image and convert to data URL\n  loadImageAsDataUrl(imageUrl) {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      img.crossOrigin = 'anonymous';\n      \n      img.onload = () => {\n        try {\n          const canvas = document.createElement('canvas');\n          const ctx = canvas.getContext('2d');\n          \n          canvas.width = img.width;\n          canvas.height = img.height;\n          \n          ctx.drawImage(img, 0, 0);\n          const dataUrl = canvas.toDataURL('image/jpeg', 0.8);\n          resolve(dataUrl);\n        } catch (error) {\n          reject(error);\n        }\n      };\n\n      img.onerror = () => {\n        reject(new Error(`Failed to load image: ${imageUrl}`));\n      };\n\n      // Add cache-busting and error handling\n      const urlWithParams = this.addCacheBusting(imageUrl);\n      img.src = urlWithParams;\n    });\n  }\n\n  // Add cache-busting parameters to URL\n  addCacheBusting(url) {\n    try {\n      const urlObj = new URL(url);\n      // Only add cache-busting if it's not already there\n      if (!urlObj.searchParams.has('_cb')) {\n        urlObj.searchParams.set('_cb', Date.now().toString(36));\n      }\n      return urlObj.toString();\n    } catch (error) {\n      // If URL is malformed, return as-is\n      return url;\n    }\n  }\n\n  // Generate placeholder image\n  getPlaceholderImage() {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    \n    canvas.width = 200;\n    canvas.height = 300;\n    \n    // Create gradient background\n    const gradient = ctx.createLinearGradient(0, 0, 0, 300);\n    gradient.addColorStop(0, '#f3f4f6');\n    gradient.addColorStop(1, '#e5e7eb');\n    \n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, 200, 300);\n    \n    // Add book icon\n    ctx.fillStyle = '#9ca3af';\n    ctx.font = '48px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText('ðŸ“š', 100, 150);\n    \n    // Add text\n    ctx.fillStyle = '#6b7280';\n    ctx.font = '14px Arial';\n    ctx.fillText('Sin portada', 100, 200);\n    \n    return canvas.toDataURL('image/png');\n  }\n\n  // Clean old cache entries\n  cleanCache() {\n    const entries = Array.from(this.cache.entries());\n    \n    // Sort by timestamp (oldest first)\n    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);\n    \n    // Remove oldest 25% of entries\n    const toRemove = Math.floor(entries.length * 0.25);\n    for (let i = 0; i < toRemove; i++) {\n      this.cache.delete(entries[i][0]);\n    }\n  }\n\n  // Get cache statistics\n  getCacheStats() {\n    const totalSize = this.cache.size;\n    const loadingCount = this.loading.size;\n    \n    // Calculate total cache size in bytes (approximate)\n    let totalBytes = 0;\n    this.cache.forEach(entry => {\n      // Approximate data URL size\n      totalBytes += entry.dataUrl.length;\n    });\n\n    return {\n      totalImages: totalSize,\n      loadingImages: loadingCount,\n      approximateSize: this.formatBytes(totalBytes),\n      maxCacheSize: this.maxCacheSize\n    };\n  }\n\n  // Format bytes for display\n  formatBytes(bytes) {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n\n  // Clear all cache\n  clearCache() {\n    this.cache.clear();\n    this.loading.clear();\n  }\n\n  // Preload images for better UX\n  async preloadImages(imageUrls) {\n    const promises = imageUrls\n      .filter(url => url)\n      .map(url => this.getCachedImage(url).catch(() => null));\n    \n    await Promise.allSettled(promises);\n  }\n\n  // Get optimized image URL based on size requirements\n  getOptimizedImageUrl(imageLinks, size = 'medium') {\n    if (!imageLinks || typeof imageLinks !== 'object') {\n      return null;\n    }\n\n    // Priority order for different sizes\n    const sizePriority = {\n      thumbnail: ['thumbnail', 'small', 'medium', 'large'],\n      small: ['small', 'thumbnail', 'medium', 'large'],\n      medium: ['medium', 'small', 'large', 'thumbnail'],\n      large: ['large', 'medium', 'small', 'thumbnail']\n    };\n\n    const priorities = sizePriority[size] || sizePriority.medium;\n    \n    for (const priority of priorities) {\n      if (imageLinks[priority]) {\n        return imageLinks[priority];\n      }\n    }\n\n    return null;\n  }\n}\n\n// Create singleton instance\nconst imageCache = new ImageCache();\n\nexport default imageCache;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}